#!/usr/bin/env python

"""
Clone a dhis2 installation from another server.
"""

import sys
import os
import time
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter as fmt
from ConfigParser import ConfigParser, ParsingError

import psycopg2


TIME = time.strftime('%Y-%m-%d_%H%M')


def main():
    args = get_args()
    cfg = get_config(args.config)

    server_dir, backups_dir = cfg['server_dir'], cfg['backups_dir']
    backup_name = cfg['backup_name']
    war_local_path = '%s/webapps/%s' % (server_dir, cfg['war_local'])
    db_local, db_remote = cfg['db_local'], cfg['db_remote']

    stop_tomcat(server_dir)
    backup_db(backups_dir, backup_name, db_local)
    backup_war(backups_dir, war_local_path)
    get_webapps(server_dir, cfg['war_local'], cfg['war_remote'])
    get_db(db_local=db_local, db_remote=db_remote)
    if args.no_data:
        delete_data(db_local)
    start_tomcat(server_dir)


def get_config(fname):
    "Return dict with the options read from configuration file"
    print('Reading from config file %s ...' % fname)
    cp = ConfigParser()
    try:
        cp.readfp(open(fname))
        check_config(cp)
    except (AssertionError, IOError, ParsingError) as e:
        sys.exit('Error reading config file %s: %s' % (fname, e))
    return dict(cp.items('clone'))


def get_args():
    "Return arguments"
    parser = ArgumentParser(description=__doc__, formatter_class=fmt)
    parser.add_argument('--config', default='dhis2_clone.cfg',
                        help='file with configuration')
    parser.add_argument('--no-data', action='store_true',
                        help='copy only metadata (copy no data)')
    # We may have more fancy stuff in the future.
    return parser.parse_args()


def check_config(cp):
    "Assert all the options in configuration exist and have reasonable values"
    assert cp.has_section('clone'), 'Missing section [clone]'
    cfg = dict(cp.items('clone'))
    for option in ['backups_dir', 'backup_name', 'server_dir',
                   'db_local', 'db_remote', 'war_local', 'war_remote']:
        assert option in cfg, 'Missing option "%s"' % option
    for path in ['backups_dir', 'server_dir']:
        assert os.path.isdir(cfg[path]), \
            '%s is not a directory: %s' % (path, cfg[path])
    assert (os.path.isfile(cfg['server_dir'] + '/bin/startup.sh') and
            os.path.isfile(cfg['server_dir'] + '/bin/shutdown.sh')), \
            ('%s should be a directory with start/stop scripts in bin: %s' %
             ('server_dir', cfg['server_dir']))
    for uri in ['db_local', 'db_remote']:
        assert is_good_db_uri(cfg[uri]), 'bad %s uri: %s' % (uri, cfg[uri])
    for war in ['war_local', 'war_remote']:
        assert cfg[war].endswith('.war'), \
            'war file does not end with .war: %s' % cfg[war]


def is_good_db_uri(uri):
    return uri.startswith('postgresql://')  # we could be way more sophisticated


def run(cmd):
    print(magenta(cmd))
    ret = os.system(cmd)
    if ret != 0:
        sys.exit(ret)


def magenta(txt):
    return '\x1b[35m%s\x1b[0m' % txt


def start_tomcat(server_path):
    run('%s/bin/startup.sh' % server_path)


def stop_tomcat(server_path):
    run('%s/bin/shutdown.sh' % server_path)


def backup_db(backups_dir, backup_name, db_local):
    backup_file = '%s/%s_%s.dump' % (backups_dir, backup_name, TIME)
    run("pg_dump --file %s --format custom --clean '%s'" % (backup_file,
                                                            db_local))


def backup_war(backups_dir, war_path):
    warname = war_path.split('/')[-1][:-4]
    backup_file = '%s/%s_%s.war' % (backups_dir, warname, TIME)
    run('cp %s %s' % (war_path, backup_file))


def get_webapps(server_dir, war_local, war_remote):
    path = '%s/webapps' % server_dir
    run('rm -rf %s/*' % path)
    run("scp -r 'prod:%s/*' %s" % (path, path))
    if war_local != war_remote:
        run('mv %s/%s %s/%s' % (path, war_remote, path, war_local))
        run('mv %s/%s %s/%s' % (path, war_remote[:-4], path, war_local[:-4]))


def get_db(db_local, db_remote):
    empty_db(db_local)
    exclude = ("--exclude-table 'aggregated*' --exclude-table 'analytics*' "
               "--exclude-table 'completeness*' --exclude-schema sys")
    dump = ("pg_dump -d '%s' --no-owner %s" %
            (db_remote, exclude))
    run("ssh prod %s | psql -d '%s'" % (dump, db_local))
    # I'd prefer to do it with:
    #    dump = ("pg_dump -d '%s' --format custom --clean --no-owner %s" %
    #            (db_remote, exclude))
    #    user = db_local[len('postgresql://'):].split(':')[0]
    #    run("ssh prod %s | pg_restore -d '%s' --no-owner --role %s" %
    #        (dump, db_local, user))
    # but it causes problems with the user role.


def empty_db(db_local):
    "Empty the contents of database"
    db_name = db_local.split('/')[-1]
    with psycopg2.connect(db_local) as conn:
        with conn.cursor() as cur:
            cur.execute("SELECT table_name FROM information_schema.views "
                        "WHERE table_schema='public' "
                        "AND table_catalog='%s'" % db_name)
            results = cur.fetchall()
            views = zip(*results)[0] if results else []
            print(magenta("Dropping %d views ..." % len(views)))
            for view in views:
                cur.execute("DROP VIEW IF EXISTS %s CASCADE" % view)
                conn.commit()

            cur.execute("SELECT table_name FROM information_schema.tables "
                        "WHERE table_schema='public' "
                        "AND table_catalog='%s'" % db_name)
            results = cur.fetchall()
            tables = zip(*results)[0] if results else []
            print(magenta("Dropping %d tables ..." % len(tables)))
            for table in tables:
                cur.execute("DROP TABLE IF EXISTS %s CASCADE" % table)
                conn.commit()

            cur.execute("SELECT sequence_name FROM information_schema.sequences "
                        "WHERE sequence_schema='public' "
                        "AND sequence_catalog='%s'" % db_name)
            results = cur.fetchall()
            sequences = zip(*results)[0] if results else []
            print(magenta("Dropping %d sequences ..." % len(sequences)))
            for sequence in sequences:
                cur.execute("DROP SEQUENCE IF EXISTS %s CASCADE" % sequence)
                conn.commit()

            # If we had permissions, it would be as simple as a
            #   DROP DATABASE dbname
            #   CREATE DATABASE dbname
            # but we may not have those permissions.


def delete_data(db_local):
    "Delete data from the tables with values"
    data_tables = """\
organisationunitattributevalues
programattributevalues
datasetattributevalues
categoryoptioncomboattributevalues
categoryoptiongroupattributevalues
constantattributevalues
dataelementattributevalues
dataelementcategoryoptionattributevalues
dataelementgroupattributevalues
documentattributevalues
indicatorattributevalues
indicatorgroupattributevalues
legendsetattributevalues
optionattributevalues
optiongroupattributevalues
optionsetattributevalues
orgunitgroupattributevalues
orgunitgroupsetattributevalues
programindicatorattributevalues
programindicatorgroupattributevalues
programstageattributevalues
sectionattributevalues
sqlviewattributevalues
trackedentityattributeattributevalues
trackedentityattributereservedvalue
trackedentityattributevalueaudit
trackedentityattributevalue
trackedentityattributevalues
userattributevalues
usergroupattributevalues
attributevalue
optionvaluetranslations
optionvalue
trackedentitydatavalueaudit
trackedentitydatavalue
keyjsonvalue
userkeyjsonvalue
datavalueaudit
datavalue
programstageinstance_messageconversation
programstageinstancecomments
programstageinstance
""".split()

    db_name = db_local.split('/')[-1]
    with psycopg2.connect(db_local) as conn:
        with conn.cursor() as cur:
            for table in data_tables:
                print(magenta("Deleting contents of table %s ..." % table))
                cur.execute("DELETE FROM %s" % table)
                conn.commit()



if __name__ == '__main__':
    main()
